# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
  branches:
    include:
    - master
  paths:
    include:
    - global/*

pool:
  vmImage: ubuntu-latest

steps:
- checkout: self
  fetchDepth: 2

- script: |
    FILES=$(git diff --name-only HEAD~1 HEAD)
    echo "##vso[task.setvariable variable=changedFiles]$FILES"
  displayName: 'Get changed files'

- script: |
    echo $(changedFiles)
  displayName: 'Display changed files'

- script: |
    cat $(changedFiles)
  displayName: 'View content of changedFiles'

- script: |
    if [[ "$(changedFiles)" == global* ]]; then
      echo "##vso[task.setvariable variable=startsWithGlobal]true"
      LAST_PART=$(basename $(changedFiles))
      echo "##vso[task.setvariable variable=lastPart]$LAST_PART"
      FIRST_PART=${LAST_PART:0:-33}
      echo "##vso[task.setvariable variable=firstPart]$FIRST_PART"
    else
      echo "##vso[task.setvariable variable=startsWithGlobal]false"
      exit 1
    fi
  displayName: 'Check if changedFiles starts with "global"'

- script: |
    pip install lxml
  displayName: 'Install lxml'

- script: |
    python -c "
    import lxml.etree as ET
    import hashlib

    def remove_cdata_tags(text):
        return text.replace('<![CDATA[', '').replace(']]>', '')

    def hash_content(content):
        return hashlib.sha256(content.encode()).hexdigest()

    parser = ET.XMLParser(remove_blank_text=True)
    tree = ET.parse('$(changedFiles)', parser)
    root = tree.getroot()

    for script in root.iter('script'):
        cdata = script.text  # get CDATA content
        if cdata:
            # print(cdata)
            cdata_content = remove_cdata_tags(cdata)  # remove CDATA tags
            print(cdata_content)
            hash_value = hash_content(cdata_content)  # get SHA-256 hash of the content
            script.text = hash_value  # replace the content of the script tag with the hash value
            print(hash_value)
            # with open('script.js', 'w') as f:
            with open(f'{hash_value}.js', 'w') as f:
                f.write(cdata_content + '\n')

        # Set an Azure Pipelines variable with the hash value
        print(f'##vso[task.setvariable variable=hashValue]{hash_value}')

    # Write the modified XML to a new file
    tree.write('$(lastPart)', pretty_print=True, xml_declaration=True, encoding='utf-8')
    "
  displayName: 'Extract <script> content to script.js'


- script: |
    echo $(hashValue)
  displayName: 'Print hashValue'


- script: |
    echo "Current Directory:"
    pwd
    echo "List files:"
    ls -la
    cat $(hashValue).js
    cat $(lastPart)
  displayName: 'View content of script and modified.xml'


- task: ServiceNow-DevOps-Config-Agent-Upload-Config@1
#  condition: eq(variables['startsWithGlobal'], 'true')
  inputs:
    connectedServiceName: 'snow8'
    applicationName: 'Snow8Demo'
    uploadTarget: 'component'
    configFile: '$(lastPart)'
    namePath: '$(firstPart)'
    dataFormat: 'xml'
    autoValidate: true
    autoCommit: true
    convertPath: true


- task: ServiceNow-DevOps-Config-Agent-Export-Snapshot@1
  inputs:
    connectedServiceName: 'snow8'
    applicationName: 'Snow8Demo'
    deployableName: 'TestJS'
    exporterName: 'returnESLint'
    dataFormat: 'yaml'
    saveFile: true
    fileName: 'config_eslint.json'


- task: CmdLine@2
  inputs:
    script: |
      echo Tree
      tree $(Pipeline.Workspace)
      echo BR-#############
      ls -la $(Pipeline.Workspace)
      echo BR-#############
      ls -la $(Pipeline.Workspace)/s
      echo BR-#############
      cat $(Pipeline.Workspace)/config_eslint.json
  displayName: 'List content'

# - script: |
#     cat -v $(Pipeline.Workspace)/config_eslint.json
#   displayName: 'View content of config_eslint.json'

# - script: |
#     echo "File content:"
#     iconv -f UTF-16 -t UTF-8 /home/vsts/work/1/config_eslint.json | cat -v
#   displayName: 'Inspect File'

# - script: |
#     echo "File content:"
#     less /home/vsts/work/1/config_eslint.json
#   displayName: 'Inspect File-less'


- script: |
    hexdump -C $(Pipeline.Workspace)/config_eslint.json
  displayName: 'View content of config_eslint.json'

# - script: |
#     echo '{
#         "env": {
#             "browser": true,
#             "es6": true
#         },
#         "globals": {
#             "current": "readonly",
#             "previous": "readonly",
#             "g_scratchpad": "readonly",
#             "gs": "readonly",
#             "GlideRecord": "readonly",
#             "GlideElement": "readonly",
#             "GlideSystem": "readonly",
#             "GlideAjax": "readonly"
#         },
#         "extends": "eslint:recommended",
#         "parserOptions": {
#             "ecmaVersion": 2015
#         },
#         "rules": {
#         }
#     }' > .eslintrc.json
#   displayName: 'Create ESLint configuration'



- script: |
    npm install eslint
  displayName: 'Install ESLint'

# - script: |
#     npx eslint script.js # this stops pipeline because of identified JS errors, problems
#   displayName: 'ESLint Check'

# npx eslint -c path_to_your_eslint_config_file script.js || true

# - script: |
#     npx eslint -c sn_eslint_config.json $(hashValue).js || true
#   displayName: 'ESLint Check'

- script: |
    npx eslint -c $(Pipeline.Workspace)/config_eslint.json $(hashValue).js || true
  displayName: 'ESLint Check'

- script: |
    npm install prettier
  displayName: 'Install Prettier'

# - script: |
#     npx prettier --check $(hashValue).js
#   displayName: 'Prettier Code Formatting'

- script: |
    npx prettier $(hashValue).js
  displayName: 'Prettier Code Formatting'

- script: |
    npx prettier --write $(hashValue).js
  displayName: 'Prettier Code Formatting'

- script: |
    cat $(hashValue).js
  displayName: 'Print final'